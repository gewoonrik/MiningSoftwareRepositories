incorporating   into a git repo, using subtree merging  i'm working on a project where we'd like to edit the less files that came with    . the  standard advice  is to leave those files untouched, to make it easier to upgrade  . but that advice isn't working for us; our code is becoming fragile and hard to maintain.    it seems like it should be possible to solve this with git subtree merging: we could edit  's less files to have clear, maintainable code, then use git's merge tools to bring in new versions of  .    we've come up with a plan for using subtree merging. but before we put the plan into action, i'd like to get some feedback:  are there significant drawbacks that we've overlooked? is there a better/simpler approach?     approaches with significant drawbacks    in the  simplest approach  to subtree merging, all the commits from the subtree (i.e.,  ) are merged into your project's  master  branch. the drawback is that   has so many commits, our commits get lost in the noise. we'd like to keep their commits off our  master  branch.     in theory, we could use  git rebase -i  to squash all the   commits into one commit, that we then merge into  master . but  rebase -i   does not work well with merges .     @sigi  helpfully suggested  that we use squash merges to go from   -upstream  to  master . grabbing the initial version of   (v3.1.0) worked ok. but when we merged in the next version (v3.1.1), we over 100 merge conflicts. every   change between 3.1.0 and 3.1.1 was flagged as a conflict. (our exact steps are in  this gist .)    the plan    our plan is to use a branch,  merge-from-  , for pulling   commits into our repository. when merging changes  in to    merge-from-   (either our changes on  master , or  's changes), always record the merge. when merging  out from   merge-from-   to  master , use  git merge --squash  so that the merge is not recorded.     our hope is that:       master  stays managable, because the   commits never become part of that branch.   git has as much information as possible when merging in a new version of  , since the  merge-from-   branch has the full history of our changes and the   team's changes.      proof of concept    in the following steps, we grab   v3.1.0, make some changes, and then upgrade to v3.1.1. the poc seems to work well (as did my tests with our real repo), but i'd like to know if we're setting ourselves up for trouble down the line.    start with a new repo, where the only file is  readme.md  (i.e., the new repo that github gives you).     # add   as a remote git remote add     .git # only fetch the master branch; don't fetch tags git config remote. .fetch +refs/heads/master:refs/remotes/ /master git config remote. .tagopt --no-tags git fetch    # start with   v3.1.0 git checkout -b merge-from-  # sha is the commit tagged v3.1.0 from the   repo git merge -s ours --no-commit 1409cde7e800ca83fd761f87e5ad8f0d259e38d1 git read-tree -u --prefix= / 1409cde7e800ca83fd761f87e5ad8f0d259e38d1 git commit -am "  v3.1.0"  # merge   3.1.0 to master git checkout master git merge --squash merge-from-  git commit -am "merge   v3.1.0 to master"  # make some changes on master, so that we have something to # be merged sed -e 's/= space/= force-merge-conflict/g' -i ''  /.editorconfig git commit -am "force a merge conflict" sed -e 's/"helvetica neue"/"comic sans"/g' -i ''  /less/variables.less  git commit -am "comic sans"  # get ready to upgrade to the new version of   git checkout merge-from-  git merge -s recursive -xtheirs master  # merge in   v3.1.1 from  /master to # merge-to- . (sha is for v3.1.1 from the   repo) git merge -s recursive -x subtree=  --no-commit a365d8689c3f3cee7f1acf86b61270ecca8e106d  # fix the merge conflict, then do: git commit -am "merged in   v3.1.1"  # merge back to master git checkout master git merge --squash merge-from-     